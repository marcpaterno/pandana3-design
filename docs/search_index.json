[["index.html", "PandAna 3 Design Preface", " PandAna 3 Design Marc Paterno 2021-09-11 Preface This design document is current a work in progress. The design of PandAna 3 is not yet complete; in fact, it is far from complete. It will be continually updated as our understanding of what is needed by the experimenters is needed. This work is being done as part of the SciDAC project HEP analytics on HPC. "],["what-pandana-is-for-and-why-we-are-designing-pandana-3.html", "Chapter 1 What PandAna is for, and why we are designing PandAna 3", " Chapter 1 What PandAna is for, and why we are designing PandAna 3 Starting from PandAna 2, the project goals have been the development of an easy-to-use environment for fast and scalable analysis. We achieve ease-of-use by the use of Python and Python data science tools (numpy and pandas). PandAna 2 has support for parallel processing of data using MPI. It does this in a manner that lets users almost entirely ignore any issues regarding MPI. This is primarily done by arranging the reading of the HDF5 files to assure that data from a single event is never split across MPI ranks. Because an analysis can treat event independently, this means user code never needs to communicate between MPI ranks. The result is that the same code that works in a serial program will also work in a parallel program. This program organization yields excellent (very nearly perfect) scaling properties for the in-memory processing portion of an analysis. However, the reading performance becomes a limiting factor for relatively small MPI programs—those using a few hundred MPI ranks. This is because good performance is obtained from the HDF5 reading only when the size of each dataset read by each rank is large. The goal of PandAna 3 is to further the abilities of PandAna 2, to include automated MPI parallelism and high-performance IO (especially reading) of large data samples. Furthermore, we are looking to redesign the internals of PandAna to allow the automatic optimization of workflows by scheduling both reading of data and evaluation of calculations in the most efficient fashion. Our plans for re-design include introducing something like an abstract syntax tree (AST) to describe the “calculation” done in an analysis. The calculation in question is the creation of a table of data (in HEP, often called an ntuple) to be used tasks such as the creation of histograms or other plots, the calculation of summary statistics, and for fitting. We are introducing an AST to provide the opportunity to apply optimizations of the calculation before evaluation of the calculated result; the formal separation of the creation of the AST from its evaluation. "],["basic-elements.html", "Chapter 2 Basic elements 2.1 Vars 2.2 Cuts 2.3 Filtering 2.4 Indexing 2.5 Grouping 2.6 Other things that are interesting", " Chapter 2 Basic elements In PandAna, the basic calculational elements are Cuts and Vars. A Var represents data; a Cut represents selections done on the data. 2.1 Vars The central feature of an “analysis”, as we represent it, is the evaluation of one or more Vars. A Var represents data that are either read directly from an input file or calculated by the analysis program, typically from other data read from the input file. From these Vars we can make histograms, scatterplots, statistical summaries, etc. A Var evaluates to a table, in our implementation a pandas.DataFrame (henceforth, just DataFrame). The evaluation of a Var requires the specification of a file to be used as the source of data for that Var. We have identified several types of Vars. SimpleVar: A SimpleVar is responsible only for reading data from a file. It performs no operations on those data. MutatedVar: A MutatedVar is based upon some other Var, and also contains a function that transforms the DataFrame to which that Var evaluate in order to yield the value of the MutatedVar. GroupedVar: 2.1.1 FilteredVar 2.1.2 ArithmeticVar 2.2 Cuts A Cut: evaluates to an array of booleans (either an np.ndarray or a DataFrame with one boolean column). gets applied to Vars to select the rows that “pass the cut”. We have identified only a few types of Cuts. 2.3 Filtering 2.4 Indexing 2.5 Grouping 2.6 Other things that are interesting "],["filteredvar-design.html", "Chapter 3 FilteredVar design 3.1 Prefer to fail early 3.2 Current design candidate 3.3 Metadata describing the objects in a table 3.4 Random questions and observations 3.5 Use cases 3.6 Non-use cases", " Chapter 3 FilteredVar design A FilteredVar represents data that has been subjected to some sort of filtering process (a cut). Each FilteredVar contains a Cut (which represents the filtering condition) and a Var (which represents the data which are to be filtered). The Cut contains its own Var, which contains the data which are used to evaluate the predicate that is part of the Cut. Evaluation of the FilteredVar proceeds by: evaluation of the Cut, which yields a boolean pd.Series defining the rows of its Var which pass the selection criteria. evaluation of the Var, which yields a pd.DataFrame. application of the pd.Series to the pd.DataFrame to yield the final pd.DataFrame. Note that the Vars involved in this calculation can be any type of Var, nor just SimpleVars. The major issue our design must resolve is: how do we make sure the Var and the Cut in the FilteredVar are compatible, meaning that it is meaningful to use the pd.Series yielded by evaluating the Cut to the pd.DataFrame yielded by evaluating the base Var? This is meaningful only when the series and the dataframe contain entries that correspond to the same object. For example, it is meaningful to make a cut based on a quality measure for electrons found by algorithm A and to apply that cut on kinematic quantities of electrons found by the same algorithm, even if the kinematic quantities and quality measures are found in different tables. It does not make sense to apply a cut created on a muon quality measure to a table of electrons, nor does it make sense to apply a cut on a quality measure for electrons found by algorithm A to the kinematic quantities of electrons found by algorithm B. Because the Vars involved in the FilteredVar may not be SimpleVars, we must be able to extend the verification of consistency to work between any two types of Vars. 3.1 Prefer to fail early It would be good to be able to sanity-check a FilteredVar without needing to refer to the data file. Since that does not seem possible, it it would be better to sanity-check a FilteredVar based only by reading file metadata rather than failing at dataframe-processing time after reading large data from the file. There may be some incompatibilities that can only be detected after we have read data from the file, if at all. Not all errors can be diagnosed. 3.2 Current design candidate We are relying upon metadata stored in each Group in the file. The metadata are stored in an Attribute named index_cols; this is a list of the names of the Datasets in the Group which are index columns, in the correct order to define a unique multidimensional index (in the sense of Pandas). The intent is to use this index information to allow the determination of whether a FilteredVar is well-formed or not. Note that this design is not sufficient to assure that a FilteredVar is well-formed. In an example data file only slightly different in design from ours, if the muons and electrons tables both had as their index columns evtnum and idx, then we could not determine that they were incompatible. If the electrons and electrons_qual tables did not have the same index columns, then we could not tell that they are compatible. Question: Are the NOvA tables all labeled in a fashion compatible with this use? 3.3 Metadata describing the objects in a table If each table were to contain metadata labeling the objects in the table, we could use that metadata to determine whether two tables were appropriate for combination. This was rejected because it is unclear how to organize these metadata to allow scaling; if the Vars involved in the process are not SimpleVars, how do we calculate the appropriate metadata? Instead, the metadata we have available for each Group is the (ordered) list of names of index columns for that Group. 3.4 Random questions and observations We need to know what columns need to be read to be used for indexing. We do not want to require that user to specify the columns. (Data columns to be read are already specified by the user.) We do not want to read any more columns than are necessary. Do we need to distinguish between index columns and data columns inside of Vars? This now seems necessary. The types Index and Grouping, and their subtypes, do not have a clear meanings and are possibly redundant. 3.5 Use cases In this section of the document, we list some use cases that illustrate what kinds of things a FilteredVar should be able to do. In the following section, we list some cases of things that do not make sense, and so that we would like FilteredVar to diagnose as wrong, if it is possible to do so. Each case comes with a textual description (generally brief), and a table showing for the Var and Cut data member of the FilteredVar, and d an example of the list of index columns that Var has access to. Note that not all of these index columns need to be read; part of what we are doing is finding a design that allows us to read the minimal amount of index information. The names of the columns are intentionally chosen to be very abstract. Note in real experiments’ data, the names will not be things like a and b; they will be things like eventnum and electron_idx. The last item on each line is a text description of what is represented by the Var or Cut. The diagrams below are UML object diagrams. Each box shows a specific object. The top part of the box shows either the object name and its type, or just its type The bottom part of the box shows some of data owned by the object, specifically basic types. The lines also show data ownership of more complex types. Note that in these diagrams the index_columns are those that are available to be read, not those that must be read. 3.5.1 UC 1 We want electron pt and phi for all electrons in events with met &gt; 10. index columns description cut a events [met &gt; 10] var a b electrons [pt, phi] Only the index column a must be read to evaluate this Var. FilteredVar for UC 1 3.5.2 UC 2 In this case, the var inside the FilteredVar is itself a FilteredVar. We want electron quality information for electrons with pt &gt; 15 in events with met &gt; 10. index columns description v1 a events [met] c1 a events [met &gt; 10] v2 a b electrons [pt] fv1 a b electrons [pt] in interesting events var a b electrons_qual [q1, q2] cut a b electrons [pt &gt; 15] in interesting events FilteredVar for UC 2 What index columns need to be read to do the evaluation? We need a in order to get the first cut to work. Because the electrons and electrons_qual tables have identical indexing, we do not actually need to read the b column to get the right alignment of rows; a simple index on the dataframe should suffice. We have a test in our system that verifies this behavior of Pandas. 3.5.3 UC 3 This case is similar to UC 2, with the difference that the index columns of the var in the FilteredVar are different than the index columns in its cut. We want electron hit energy information for hits in electrons, for those electrons with pt &gt; 15, in events with met &gt; 10. index columns description v1 a events [met] c1 a events ]met &gt; 10] v2 a b electrons [pt] fv1 a b electrons [pt] in interesting events cut a b electrons [pt &gt; 15] in interesting events var a b c electrons_hits [energy] FilteredVar for UC 3 In this case, we need to read index columns a and b, so that the rows in the dataframe from var can be correctly aligned with the elements in the series from cut. 3.6 Non-use cases Note that cases we do not want to support often have descriptions that are clearly incoherent. This is why we do not want to support them! The key is to make the code automatically detect the incoherence, when possible. People do make mistakes in code, and we want to catch as many of them as we can. 3.6.1 NUC 1 We want event met for electrons with quality q1 &gt; 0.75. index columns description cut a b electrons_qual [q1 &gt; 0.75] var a events [met] 3.6.2 NUC 2 More to come! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
